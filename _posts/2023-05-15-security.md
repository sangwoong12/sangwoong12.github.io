---
title: JPA
date: 2023-05-08 09:00:00 +0800
categories: [security]
tags: [jpa]
---

# Spring Security

- Spring 기반 애플리케이션을 위해 선언적 보안 기능을 제공하는 보안 프레임워크
- Servlet Filter 및 AOP 기반

# 인증 관련 Architecture 설명 (로그인 인증)
<img src="/images/security/1.png">

- 사용자가 아래와 같은 방식으로 로그인을 요청을 했다고 가정을하자.

```json
  {
  "username": "admin",
  "password": 12345
}
```

## 1. Http Request 요청

- 사용자가 인증 요청이 들어오면 AuthenticationFilter 를 들리게 된다.

```java
public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter {

  public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
    if (this.postOnly && !request.getMethod().equals("POST")) {
      throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());
    } else {
      String username = this.obtainUsername(request); // username : "admin"
      username = username != null ? username.trim() : "";
      String password = this.obtainPassword(request); // password : "password"
      password = password != null ? password : "";
      // 토큰 생성
      UsernamePasswordAuthenticationToken authRequest = UsernamePasswordAuthenticationToken.unauthenticated(username, password);
      this.setDetails(request, authRequest);
      return this.getAuthenticationManager().authenticate(authRequest);
    }
  }
}
```

- 해당 메서드 에서드에서 **UsernamePasswordAuthenticationToken.unauthenticated(username, password)** 를 호출하여
  UsernamePasswordAuthenticationToken 로 이동한다.

## 2. UsernamePasswordAuthenticationToken

```java
public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken {
  private final Object principal;
  private Object credentials;
  //생성자
  public UsernamePasswordAuthenticationToken(Object principal, Object credentials) {
    super((Collection) null); // 상위 클래스인 AbstractAuthenticationToken 에 authorities = null 설정 즉, 아직 인가정보가 없기 때문에 null 로 설정.
    this.principal = principal; // principal : admin (아이디)
    this.credentials = credentials; // credentials : 12345 (패스워드)
    this.setAuthenticated(false); // 인증 처리전 이기 떄문에 false 로 설정
  }
  //filter 에서 호출하는 메서드
  public static UsernamePasswordAuthenticationToken unauthenticated(Object principal, Object credentials) {
    return new UsernamePasswordAuthenticationToken(principal, credentials);
  }

  public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException {
    Assert.isTrue(!isAuthenticated, "Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead");
    super.setAuthenticated(false);//AbstractAuthenticationToken 설정
  }
}
```

1. unauthenticated 를 호출하여 생성자를 호출
2. 생성자를 통해 token 을 생성
3. 상위 클래스 AbstractAuthenticationToken 설정

```java
public abstract class AbstractAuthenticationToken implements Authentication, CredentialsContainer { // token 은 보다시피 Authentication 구현체 이다.
  private final Collection<GrantedAuthority> authorities; // size = 0 즉, 없다.
  private Object details; // null
  private boolean authenticated; // false;

  public void setAuthenticated(boolean authenticated) {
    this.authenticated = authenticated;
  }
}
```

4. 이렇게 생성된 토큰을 filter 로 보냄

## 3. AuthenticationManager (ProviderManager)

```java
public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter {
  public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
      // ...
      // 토큰 생성
      UsernamePasswordAuthenticationToken authRequest = UsernamePasswordAuthenticationToken.unauthenticated(username, password);
      this.setDetails(request, authRequest);
      return this.getAuthenticationManager().authenticate(authRequest);
  }
}
```

1. token 을 받아온 filter 는 상위 클래스인 AbstractAuthenticationProcessingFilter 의 getAuthenticationManager 메서드를 통해
  AuthenticationManager 를 받아와서 authenticate 메서드 인자로 토큰을 전달 한다.
2. AuthenticationManager 는 인터페이스 이고 구현체인 ProviderManager 에서 authenticate 를 실행한다.

```java
public class ProviderManager implements AuthenticationManager, MessageSourceAware,
InitializingBean {
    public List<AuthenticationProvider> getProviders() {
		return providers;
	}
    public Authentication authenticate(Authentication authentication)
			throws AuthenticationException {
		Class<? extends Authentication> toTest = authentication.getClass(); // passwordAuthenticationToken [Principal : admin , Credentials : 12345]
		AuthenticationException lastException = null;
		Authentication result = null;
		boolean debug = logger.isDebugEnabled();
        //for문으로 모든 provider를 순회하여 처리하고 result 가 나올 때까지 반복한다.
		for (AuthenticationProvider provider : getProviders()) {
            //....
			try {
				result = provider.authenticate(authentication);

				if (result != null) {
					copyDetails(authentication, result);
					break;
				}
			}
			catch (AccountStatusException e) {
				prepareException(e, authentication);
				throw e;
			}
            //....
		}
		throw lastException;
	}
}
```

3. manager 는 provider 를 순회하면서 result를 받아오는 역활만 하고 실 인증 처리는 provider 가 한다.

## 4. AuthenticationProvider(s)
```java
public interface AuthenticationProvider {

	  // 인증 전의 token 을 받아서 인증된 Authentication 객체를 반환
    Authentication authenticate(Authentication var1) throws AuthenticationException;

    boolean supports(Class<?> var1);

}
```
1. Manager 에 의해 호출되었을때 AuthenticationProvider 의 구현체인 AbstractUserDetailsAuthenticationProvider 의 authenticate 메서드가 호출된다.
```java
public abstract class AbstractUserDetailsAuthenticationProvider implements AuthenticationProvider, InitializingBean, MessageSourceAware {
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, () -> {
            return this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.onlySupports", "Only UsernamePasswordAuthenticationToken is supported");
        });
        String username = this.determineUsername(authentication);
        boolean cacheWasUsed = true;
        UserDetails user = this.userCache.getUserFromCache(username);
        if (user == null) {
            cacheWasUsed = false;

            try {
                //this.retrieveUser
                user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); //load
            } catch (UsernameNotFoundException var6) {
                this.logger.debug("Failed to find user '" + username + "'");
                if (!this.hideUserNotFoundExceptions) {
                    throw var6;
                }

                throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));
            }

            Assert.notNull(user, "retrieveUser returned null - a violation of the interface contract");
        }
        //...
        return this.createSuccessAuthentication(principalToReturn, authentication, user);
    }
}
```
2. AbstractUserDetailsAuthenticationProvider 에서 **this.retrieveUser**메서드를 호출할때 구현체인 DaoAuthenticationProvider 에서 해당 메서드를 처리한다.

```java
public class DaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider {
    private UserDetailsService userDetailsService;
    private UserDetailsPasswordService userDetailsPasswordService;

    protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
        this.prepareTimingAttackProtection();

        try {
            //loadUserByUsername()
            UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);
            if (loadedUser == null) {
                throw new InternalAuthenticationServiceException("UserDetailsService returned null, which is an interface contract violation");
            } else {
                return loadedUser;
            }
        } catch (UsernameNotFoundException var4) {
            this.mitigateAgainstTimingAttack(authentication);
            throw var4;
        } catch (InternalAuthenticationServiceException var5) {
            throw var5;
        } catch (Exception var6) {
            throw new InternalAuthenticationServiceException(var6.getMessage(), var6);
        }
    }
}
```

## 5. UserDetailsService
- this.getUserDetailsService() 를 호출하여 UserDetailsService 가 호출된다.
```java
public interface UserDetailsService {
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```

## 6. UserDetails
- UserDetailsService 의 loadUserByUsername 을 호출하여 DB에 조회하여 UserDetails 를 생성한다.

## 7. AuthenticationProvider(s)
```
return this.createSuccessAuthentication(principalToReturn, authentication, user);
```
- UserDetails 를 받아 인증을 시도한 이후 인증이 성공하면 인증이 완료된 Authentication 을 반환한다.

## 8. AuthenticationManager

- 모든 provider의 인증을 통과한 Authentication 을 반환한다.

## 9. AuthenticationFilter

```java
public abstract class AbstractAuthenticationProcessingFilter extends GenericFilterBean implements ApplicationEventPublisherAware, MessageSourceAware {
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {
        SecurityContext context = this.securityContextHolderStrategy.createEmptyContext();
        context.setAuthentication(authResult);// 인증 받은 Authentication
        this.securityContextHolderStrategy.setContext(context);
        this.securityContextRepository.saveContext(context, request, response);
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(LogMessage.format("Set SecurityContextHolder to %s", authResult));
        }

        this.rememberMeServices.loginSuccess(request, response, authResult);
        if (this.eventPublisher != null) {
            this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));
        }

        this.successHandler.onAuthenticationSuccess(request, response, authResult);// successHandler
    }
}
```
1. 인증에 성공한 Authentication을 비어있는 SecurityContext 에 저장을 하고 Context 를 SecurityContextRepository 에 저장한다.
2. 이후 successHandler 에서 인증 받은 Authentication 을 이용하여 request 응답을 한다.
3. 헤더 설정도 저기서
