---
title: JPA 영속성 관리
date: 2023-05-26 09:00:00 +0800
categories: [김영한의 JPA 프로그래밍]
tags: [jpa,book]
---

## 영속성 컨텍스트란?

- 영속성 컨텍스트란 **엔티티를 영구 저장하는 환경**이라는 뜻이다.
- 엔티티 메니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리할 수 있다.

## 엔티티의 생명주기

<img src="/images/jpa/jpa3/1.png">

- 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속 : 영속성 컨텍스트에 지정된 상태
- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 : 삭제된 상태

### 비영속

```java
//객체를 생성한 상태
Member member=new Member();
member.setId("member");
member.setUsername("member");
```

- 엔티티 객체를 생성만 한 상태일 경우 순수 객체 상태이며 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없고 이상태를 **비영속 상태**라고 한다.

### 영속

```java
//객체를 저장한 상태 (영속)
em.persist(member);
```

- 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장을 하면 영속성 컨텍스트가 관리하는 엔티티를 **영속 상태**라 한다.

### 준영속

```java
//회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태
em.detach();
//영속성 컨텍스트를 닫음
em.close();
//영속성 컨텍스트를 초기화
em.clear();
```

- 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 분리하거나 컨텍스트를 초기화,닫음 상태가 되면 **준영속 상태**가 된다.

### 삭제

```java
em.remove(member);
```

- 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.

## 영속성 컨텍스트의 특징

- 영속성 컨텍스트와 식별자 값(@Id로 테이블의 기본 키와 매핑한 값)으로 구분한다.
- **영속 상태는 식별자 값이 반드시 있어야 한다.** 식별자 값이 없으면 예외 발생

### 1차 캐시

- 1차 캐시 : 영속성 컨텍스트의 내부에 존재하는 캐시
  - Map 으로 이루어져 있고 Key는 @Id로 맵핑한 식별자 값 value는 엔티티 인스턴스이다.

```java
Member member=new Member();
member.setId("member");

em.persist(member);
```

- 위와 같이 member 객체를 em.persist() 할 경우 데이터베이스에 저장되지 않고 1차 캐시에 저장된다.

### 엔티티 조회

- em.find() 를 통해 엔티티를 찾을 때
  - 1차 캐시에 해당 엔티티가 존재한다면 데이터베이스 조회를 하지 않고 해당 엔티티를 가지고 올 수 있다.
  - 1차 캐시에 없으면 데이터베이스에서 해당 엔티티를 찾아온다.

### 영속 엔티티의 동일성 보장

```java
Member a=em.find(Mamber.class,"member1");
Member b=em.find(Mamber.class,"member1");
```

- em.find() 를 통해 같은 id인 맴버를 찾았을 경우 2번째 em.find()의 경우 1차 캐시에서 찾아올태니 당연히 같은 인스턴스 이므로 a == b를 만족한다.

### 쓰기 지연

- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모아둔다.
- **트랜잭션을 커밋할때 모아둔 쿼리를 데이터베이스에 한번에** 보내게 되는데 쓰기 지연이라고 한다.

### 변경 감지

```java
Member a=em.find(Member.class,"memberA");
a.setUsername("a");
```

- 위와 같이 별도의 update 가 없이 엔티티를 수정하면 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지라고 한다.
- 변경 감지 동작방식
  - 트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 flush()가 호출된다.
  - 엔티티와 스냅샷(최초 상태)와 비교해서 변경된 엔티티를 찾는다.
  - 변경된 엔티티가 있으면 수정 쿼리를 생성하여 쓰기 지연 SQL 저장소에 보내고 데이터베이스에 보낸다.
  - 데이터베이스 트랜잭션을 커밋한다.
- 단, **변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.**

### 엔티티 삭제

```java
Member a=em.find(Member.class,"memberA");
  em.remove(a);
```

- 엔티티를 삭제하기 위해서 대상 엔티티를 조회한 후 삭제를 해야한다.
- 삭제도 마찬가지로 바로 즉시 삭제하는 것이 아닌 쓰기 지연 SQL문에 등록한 후 트랜잭션 커밋을 한후 flush가 호출 되어야 삭제된다.

## 플러시 flush()

- 플러시는 **영속성 컨텍스트의 변경 내용을 데이터베이스에 반영**한다.
- 영속성 컨텍스트를 플러시하는 방법은 3가지 있다.

### 직접 호출

- 엔티티 매니저의 flush() 메서드를 직접 호출해서 영속성 컨텍스트를 강제로 플러시 하는 방법이다.
- 테스트, 프레임워크와 JPA를 함께 사용할 떼를 제외하고 사용하지 않는다.

### 트랜잭션 커밋 시 플러시 자동 호출

- 플러시를 호출하지 않고 커밋시 데이터베이스에 반영되지 않는다.
- JPA는 이를 방지하기 위해 플러시를 자동으로 호출한다.

### JPQL 쿼리 실행 시 플러시 자동 호출

- 이 역시 위와 같은 이유로 JPA는 JPQL을 호출시 자동으로 플러시를 호출한다.

## 준영속

- 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것을 **준영속 상태**라고 한다.
- 이 상태에서의 **엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.**
- 영속 상태의 엔티티를 준영속 상태로 만드는 방법
  -
    1. em.detach(entity) : 특정 엔티티만 준영속 상태로 전환한다.
  -
    2. em.clear() : 영속성 컨텍스트를 완전히 초기화한다.
  -
    3. em.close() : 영속성 컨텍스트를 종료한다.
- 개발자가 직접 준영속 상태로 만드는 일은 드물다.

## 병합 merge()

- merge() 메서드는 준영속 상태의 엔티티를 받아서 그 정보를 **새로운 영속 상태의 엔티티를 반환**한다.

